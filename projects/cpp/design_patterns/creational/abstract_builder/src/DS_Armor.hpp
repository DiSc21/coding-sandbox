//----------------------------------------------------------------------------------------------------
//- BUILDER Pattern  ---------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------
// The builder pattern "separates the construction of a complex object from its representation".
// - This allows to create different representations with the same construction process.
// - Construction of complex objects is done step by step and the final step returns the object.
// - The construction process is generic to be be used for creation of different representations.
//
//----------------------------------------------------------------------------------------------------
//
// COMPONENTS:
// -----------
// - PRODUCT:
//   Product class defines type of the object to be generated by the builder pattern.
//
// - BUILDER:
//   Abstract base class defining the (abstract) steps needed for creation of the product.
// 
// - CONCRETE BUILDER(S):
//   Daughter(s) of abstract Builder. Here, steps for creation of particular products are implemented.
// 
// - DIRECTOR:
//   Controls the final generation of the product. Some parameter specifies the concrete builder object
//   that is to be used to generate the product. The director then calls methods of the concrete builder
//   in the correct order to generate the product object.
//
//----------------------------------------------------------------------------------------------------
//
// ADVANTAGES:
// -----------
// - Parameters for constructor are reduced providing highly readable method calls.
// - Circumvents the need for optional parameters in the constructor.
// - Object is always instantiated in a complete state.
// - Immutable objects can be build without much complex logic in the object building process.
// - Usually yields a better design flexibility
// - Usually yields a better readable code.
//----------------------------------------------------------------------------------------------------
//
// DISADVANTAGES:
// --------------
// - Number of lines of code increase to double
// - Requires a separate ConcreteBuilder for each different type of Product.
//
//----------------------------------------------------------------------------------------------------

#ifndef __DS_ARMOR__
#define __DS_ARMOR__

#include <numeric>
#include <memory>
#include <set>
#include <map>
#include <string>


/// @brief Just a an auxiliary class used in the PRODUCT class
class ArmorPart
{
  public:

    enum class Type : uint8_t
    {
        BODY,
        HEAD,
        SHOULDERS,
        ARMS,
        HANDS,
        LEGS,
        FEET,
    };

    ArmorPart() = delete;
    ArmorPart(const Type type, const std::string& name = "", const uint8_t protection = 0)
        : type_(type), name_(name), protection_(protection)
    {}

    bool operator<(const ArmorPart& rhs) const { return (type_  < rhs.type_);}

    Type        getType()       const { return type_; }
    std::string getName()       const { return name_; }
    uint8_t     getProtection() const { return protection_; }

  private:
    const Type type_;

    std::string name_;
    uint8_t protection_;
};

/// @brief the so-called PRODUCT
class Armor
{
  public:
    Armor(){}
    Armor(std::set<ArmorPart> parts)
    {
        for(const auto& part: parts)
        {
            static_cast<void>(armor_parts_.insert({part.getType(), part}));
        }
    }

    uint8_t getTypeProtection(const ArmorPart::Type type) const
    {
        const auto& part_it = armor_parts_.find(type);
        return (part_it != armor_parts_.end()) ? part_it->second.getProtection() : 0;
    }

    uint16_t getProtection() const
    {
        return std::accumulate(std::begin(armor_parts_), std::end(armor_parts_), 0,
                               [](const std::uint16_t sum, const auto& part)
                               { return sum + part.second.getProtection(); });
    }

  private:
    std::map<ArmorPart::Type, ArmorPart> armor_parts_{};
};

/// @brief the so-called (abstract) BUILDER
class ArmorBuilder_
{
  public:
    virtual Armor buildArmor() = 0;
};

/// @brief a so-called CONCRETE BUILDER
class ArmorBuilder_Civilian : public ArmorBuilder_
{
  public:
    Armor buildArmor()
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY,  "Plain Shirt", 1),
                      ArmorPart(ArmorPart::Type::LEGS,  "Cloth trousers", 1),
                      ArmorPart(ArmorPart::Type::FEET,  "Simple Shoes", 1)});
    }
};

/// @brief a so-called CONCRETE BUILDER
class ArmorBuilder_Warrior : public ArmorBuilder_
{
  public:
    Armor buildArmor()
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY,  "Leather Chest Protector", 12),
                      ArmorPart(ArmorPart::Type::HEAD,  "Leather Helmet", 7),
                      ArmorPart(ArmorPart::Type::LEGS,  "Bavarian Leather Trousers", 5),
                      ArmorPart(ArmorPart::Type::HANDS, "Leather Gloves", 4),
                      ArmorPart(ArmorPart::Type::FEET,  "Leather Boots", 3)});
    }
};

/// @brief a so-called CONCRETE BUILDER
class ArmorBuilder_Wizard : public ArmorBuilder_
{
  public:
    Armor buildArmor()
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY,  "Magic Rope", 4),
                      ArmorPart(ArmorPart::Type::HEAD,  "Pointed Hat", 3),
                      ArmorPart(ArmorPart::Type::LEGS,  "Long Underpants", 1),
                      ArmorPart(ArmorPart::Type::FEET,  "Slipers", 1)});
    }
};

/// @brief The NPC basically serves as the director with conststructor serving as creation function 
class NPC
{
  public:
    enum class Type : uint8_t
    {
        CIVILIAN,
        WARRIOR,
        WIZARD
    };

    NPC(const std::string& name, const Type type) : name_(name), type_(type)
    {
         switch (type)
         {
           case Type::CIVILIAN:
             armor_ = ArmorBuilder_Civilian().buildArmor();
             break;
           case Type::WARRIOR:
             armor_ = ArmorBuilder_Warrior().buildArmor();
             break;
           case Type::WIZARD:
             armor_ = ArmorBuilder_Wizard().buildArmor();
             break;
           default:
             armor_ = Armor();
             break;
         }
    }

    std::string getName() const { return name_; }
    Type  getType()       const { return type_; }
    Armor getArmor()      const { return armor_; }

  private:
    const std::string name_;
    const Type        type_;

    Armor armor_;
};

/// @brief just a simple collection of functions for creation of different NPC types
class NPCBuilder
{
  public:
    static std::shared_ptr<NPC> civilian(const std::string& name)
    {
        return std::make_shared<NPC>(name, NPC::Type::CIVILIAN);
    }

    static std::shared_ptr<NPC> warrior(const std::string& name)
    {
        int test = 10;
        if(false) {int klaus = test/0;}
        return std::make_shared<NPC>(name, NPC::Type::WARRIOR);
    }

    static std::shared_ptr<NPC> wizard(const std::string& name)
    {
        return std::make_shared<NPC>(name, NPC::Type::WIZARD);
    }
};

#endif

