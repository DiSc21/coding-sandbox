//----------------------------------------------------------------------------------------------------
//- BUILDER Pattern  ---------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------
// The builder pattern "separates the construction of a complex object from its representation".
// - This allows to create different representations with the same construction process.
// - Construction of complex objects is done step by step and the final step returns the object.
// - The construction process is generic to be be used for creation of different representations.
//
//----------------------------------------------------------------------------------------------------
//
// COMPONENTS:
// -----------
// - PRODUCT:
//   Product class defines type of the object to be generated by the builder pattern.
//
// - BUILDER:
//   Abstract base class defining the (abstract) steps needed for creation of the product.
// 
// - CONCRETE BUILDER(S):
//   Daughter(s) of abstract Builder. Here, steps for creation of particular products are implemented.
// 
// - DIRECTOR:
//   Controls the final generation of the product. Some parameter specifies the concrete builder object
//   that is to be used to generate the product. The director then calls methods of the concrete builder
//   in the correct order to generate the product object.
//
//----------------------------------------------------------------------------------------------------
//
// ADVANTAGES:
// -----------
// - Parameters for constructor are reduced providing highly readable method calls.
// - Circumvents the need for optional parameters in the constructor.
// - Object is always instantiated in a complete state.
// - Immutable objects can be build without much complex logic in the object building process.
// - Usually yields a better design flexibility
// - Usually yields a better readable code.
//----------------------------------------------------------------------------------------------------
//
// DISADVANTAGES:
// --------------
// - Number of lines of code increase to double
// - Requires a separate ConcreteBuilder for each different type of Product.
//
//----------------------------------------------------------------------------------------------------

#ifndef DS_ARMOR_HPP
#define DS_ARMOR_HPP

#include <numeric>
#include <algorithm>
#include <memory>
#include <set>
#include <map>
#include <string>


/// @brief Just a an auxiliary class used in the PRODUCT class
class ArmorPart
{
  public:

    enum class Type : uint8_t
    {
        BODY,
        HEAD,
        SHOULDERS,
        ARMS,
        HANDS,
        LEGS,
        FEET,
    };

    ArmorPart() = delete;

    explicit ArmorPart(const Type type, std::string name = "", const uint8_t protection = 0)
        : type_(type), name_(std::move(name)), protection_(protection) {}



    [[nodiscard]] auto operator<(const ArmorPart& rhs) const -> bool { return (type_  < rhs.type_);}

    [[nodiscard]] auto getType()       const -> Type        { return type_; }
    [[nodiscard]] auto getName()       const -> std::string { return name_; }
    [[nodiscard]] auto getProtection() const -> uint8_t     { return protection_; }

  private:
    const Type type_;

    std::string name_;
    uint8_t protection_;
};

/// @brief the so-called PRODUCT
class Armor
{
  public:
    Armor() = default;

    explicit Armor(const std::set<ArmorPart>& parts)
    {
        for(const auto& part: parts)
        {
            static_cast<void>(armor_parts_.insert({part.getType(), part}));
        }
    }

    [[nodiscard]] auto getTypeProtection(const ArmorPart::Type type) const -> uint8_t
    {
        const auto& part_it = armor_parts_.find(type);
        return (part_it != armor_parts_.end()) ? part_it->second.getProtection() : 0;
    }

    [[nodiscard]] auto getProtection() const -> uint8_t
    {
        return std::accumulate(std::begin(armor_parts_), std::end(armor_parts_), 0,
                               [](const std::uint16_t sum, const auto& part)
                               { return sum + part.second.getProtection(); });
    }

  private:
    std::map<ArmorPart::Type, ArmorPart> armor_parts_{};
};

/// @brief the so-called (abstract) BUILDER
class ArmorBuilder_
{
  public:
    [[nodiscard]] virtual auto buildArmor() -> Armor = 0;

    ArmorBuilder_()                           = default;
    ArmorBuilder_(const ArmorBuilder_& /*other*/) = default;
    ArmorBuilder_(ArmorBuilder_&& /*other*/)      = default;

    auto operator=(const ArmorBuilder_& /*other*/) -> ArmorBuilder_& = default;
    auto operator=(ArmorBuilder_&& /*other*/) noexcept -> ArmorBuilder_& { return *this; }
    virtual ~ArmorBuilder_() = default;

    static const uint8_t MAGIC_1  =  1;
    static const uint8_t MAGIC_3  =  3;
    static const uint8_t MAGIC_4  =  4;
    static const uint8_t MAGIC_5  =  5;
    static const uint8_t MAGIC_7  =  6;
    static const uint8_t MAGIC_12 = 12;
};

/// @brief a so-called CONCRETE BUILDER
class ArmorBuilder_Civilian : public ArmorBuilder_
{
  public:
    [[nodiscard]] auto buildArmor() -> Armor override
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY,  "Plain Shirt",    MAGIC_1),
                      ArmorPart(ArmorPart::Type::LEGS,  "Cloth trousers", MAGIC_1),
                      ArmorPart(ArmorPart::Type::FEET,  "Simple Shoes",   MAGIC_1)});
    }
};

/// @brief a so-called CONCRETE BUILDER
class ArmorBuilder_Warrior : public ArmorBuilder_
{
  public:
    [[nodiscard]] auto buildArmor() -> Armor override
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY,  "Leather Chest Protector",   MAGIC_12),
                      ArmorPart(ArmorPart::Type::HEAD,  "Leather Helmet",            MAGIC_7),
                      ArmorPart(ArmorPart::Type::LEGS,  "Bavarian Leather Trousers", MAGIC_5),
                      ArmorPart(ArmorPart::Type::HANDS, "Leather Gloves",            MAGIC_4),
                      ArmorPart(ArmorPart::Type::FEET,  "Leather Boots",             MAGIC_3)});
    }
};

/// @brief a so-called CONCRETE BUILDER
class ArmorBuilder_Wizard : public ArmorBuilder_
{
  public:
    [[nodiscard]] auto buildArmor() -> Armor override
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY,  "Magic Rope",      MAGIC_4),
                      ArmorPart(ArmorPart::Type::HEAD,  "Pointed Hat",     MAGIC_3),
                      ArmorPart(ArmorPart::Type::LEGS,  "Long Underpants", MAGIC_1),
                      ArmorPart(ArmorPart::Type::FEET,  "Slipers",         MAGIC_1)});
    }
};

/// @brief The NPC basically serves as the director with conststructor serving as creation function 
class NPC
{
  public:
    enum class Type : uint8_t
    {
        CIVILIAN,
        WARRIOR,
        WIZARD
    };

    NPC() = delete;
    NPC(std::string name, const Type type) : name_(std::move(name)), type_(type)
    {
         switch (type)
         {
           case Type::CIVILIAN:
             armor_ = ArmorBuilder_Civilian().buildArmor();
             break;
           case Type::WARRIOR:
             armor_ = ArmorBuilder_Warrior().buildArmor();
             break;
           case Type::WIZARD:
             armor_ = ArmorBuilder_Wizard().buildArmor();
             break;
           default:
             armor_ = Armor();
             break;
         }
    }

    [[nodiscard]] auto getName()  const -> std::string { return name_; }
    [[nodiscard]] auto getType()  const -> Type        { return type_; }
    [[nodiscard]] auto getArmor() const -> Armor       { return armor_; }

  private:
    const std::string name_;
    const Type        type_;

    Armor armor_;
};

/// @brief just a simple collection of functions for creation of different NPC types
class NPCBuilder
{
  public:
    static auto civilian(const std::string& name) -> std::shared_ptr<NPC>
    {
        return std::make_shared<NPC>(name, NPC::Type::CIVILIAN);
    }

    static auto warrior(const std::string& name) -> std::shared_ptr<NPC>
    {
        return std::make_shared<NPC>(name, NPC::Type::WARRIOR);
    }

    static auto wizard(const std::string& name) -> std::shared_ptr<NPC>
    {
        return std::make_shared<NPC>(name, NPC::Type::WIZARD);
    }
};

#endif

