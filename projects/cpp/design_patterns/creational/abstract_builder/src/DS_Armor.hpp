//*****************************************************************************************|
//     ______ _              ____            _      ,                      _               |
//    (_) |  | |            (|   \ o        | |    /|   /         o       | |              |
//        |  | |     _       |    |    ,_   | |     |__/   _  _       __, | |   _|_        |
//      _ |  |/ \   |/      _|    ||  /  |  |/_)    | \   / |/ |  |  /  | |/ \   |         |
//     (_/   |   |_/|__/   (/\___/ |_/   |_/| \_/   |  \_/  |  |_/|_/\_/|/|   |_/|_/       |
//    *****************************************************************/|***********       |
//                                                                     \|                  |
//_________________________________________________________________________________________|
//                                                                                         |
// Copyright (c) 2023  DiSc21-Fantasies@TDK. All rights reserved.                          |
// None of the code is licensed under any License.                                         |
//_________________________________________________________________________________________|
//
//------------------------------------------------------------------------------------------
//- BUILDER Pattern ------------------------------------------------------------------------
//------------------------------------------------------------------------------------------
// The builder pattern "separates the construction of a complex object from its
// representation".
// - This allows to create different representations with the same construction
// process.
// - Construction of complex objects is done step by step and the final step
// returns the object.
// - The construction process is generic to be be used for creation of different
// representations.
//
//------------------------------------------------------------------------------------------
//
// COMPONENTS:
// -----------
// - PRODUCT:
//   Product class defines type of the object to be generated by the builder
//   pattern.
//
// - BUILDER:
//   Abstract base class defining the (abstract) steps needed for creation of
//   the product.
//
// - CONCRETE BUILDER(S):
//   Daughter(s) of abstract Builder. Here, steps for creation of particular
//   products are implemented.
//
// - DIRECTOR:
//   Controls the final generation of the product. Some parameter specifies the
//   concrete builder object that is to be used to generate the product. The
//   director then calls methods of the concrete builder in the correct order to
//   generate the product object.
//
//------------------------------------------------------------------------------------------
//
// ADVANTAGES:
// -----------
// - Parameters for constructor are reduced providing highly readable method
// calls.
// - Circumvents the need for optional parameters in the constructor.
// - Object is always instantiated in a complete state.
// - Immutable objects can be build without much complex logic in the object
// building process.
// - Usually yields a better design flexibility
// - Usually yields a better readable code.
//------------------------------------------------------------------------------------------
//
// DISADVANTAGES:
// --------------
// - Number of lines of code increase to double
// - Requires a separate ConcreteBuilder for each different type of Product.
//
//------------------------------------------------------------------------------------------

#ifndef DS_ARMOR_HPP
#define DS_ARMOR_HPP

#include <algorithm>
#include <map>
#include <memory>
#include <numeric>
#include <set>
#include <string>
#include <utility>

/// @brief Just a an auxiliary class used in the PRODUCT class
class ArmorPart
{
  public:
    /// @brief simple enum descriping different armor/body parts
    enum class Type : uint8_t
    {
        BODY,
        HEAD,
        SHOULDERS,
        ARMS,
        HANDS,
        LEGS,
        FEET,
    };

    ArmorPart() = delete;

    /// @brief construnctor for armor parts
    /// @param type the type of the armor part
    /// @param name the name of the armor part
    /// @param protection the value of protection
    explicit ArmorPart(const Type type, std::string name = "", const uint8_t protection = 0)
        : type_(type), name_(std::move(name)), protection_(protection){}

    /// @brief comparison operator needed to collect ArmorPart in set
    /// @param rhs the ArmorPart standing on the rhs of the operator
    /// @return boolean, true if type smaller than rhs type
    [[nodiscard]] auto operator<(const ArmorPart &rhs) const -> bool { return (type_ < rhs.type_); }

    /// @brief type getter
    /// @return type of ArmorPart
    [[nodiscard]] auto getType() const -> Type { return type_; }
    /// @brief name getter
    /// @return name of ArmorPart
    [[nodiscard]] auto getName() const -> std::string { return name_; } ///> @brief type getter > @return type of ArmorPart
    /// @brief protection getter
    /// @return protection of ArmorPart
    [[nodiscard]] auto getProtection() const -> uint8_t { return protection_; }

  private:
    /// @brief type of the armor part
    const Type type_;

    /// @brief name of the armor part
    std::string name_;
    /// @brief protection value of the armor part
    uint8_t protection_;
};

/// @brief the so-called PRODUCT
class Armor
{
  public:
    Armor() = default; ///> the defaulted default constructor

    /// @brief single argument constructor creating armor from set of Armor parts
    /// @param parts set of armor parts
    explicit Armor(const std::set<ArmorPart> &parts)
    {
        for ( const auto &part : parts )
        {
            static_cast<void>(armor_parts_.insert({part.getType(), part}));
        }
    }

    /// @brief getter protection value for armor part-type
    /// @param type the armor part-type protection value is requested
    /// @return protection value for requested part
    [[nodiscard]] auto getTypeProtection(const ArmorPart::Type type) const -> uint8_t
    {
        const auto &part_it = armor_parts_.find(type);
        return (part_it != armor_parts_.end()) ? part_it->second.getProtection() : 0;
    }

    /// @brief getter protection value for full armor
    /// @return protection value for full armor
    [[nodiscard]] auto getProtection() const -> uint8_t
    {
        // clang-format off
        return std::accumulate(std::begin(armor_parts_), std::end(armor_parts_), 0,
                               [](const std::uint16_t sum, const auto &part) { return sum + part.second.getProtection(); });
        // clang-format on
    }

  private:
    /// @brief map of armorPartType to equiped armor part
    std::map<ArmorPart::Type, ArmorPart> armor_parts_{};
};

/// @brief the so-called (abstract) BUILDER
class ArmorBuilder_
{
  public:
    /// @brief pure virual/abstract build armor function
    /// @return Armor, i.e. collection of different armor parts
    [[nodiscard]] virtual auto buildArmor() -> Armor = 0;

    ArmorBuilder_()                                                = default; ///> default-constructor
    ArmorBuilder_(const ArmorBuilder_ & /*< other armor builder*/) = default; ///> copy-constructor
    ArmorBuilder_(ArmorBuilder_ && /*< other armor builder*/)      = default; ///> move-constructor

    /// @return ArmorBuilder
    auto operator=(const ArmorBuilder_ & /*< other*/) -> ArmorBuilder_ & = default;            ///> =ops
    /// @return ArmorBuilder
    auto operator=(ArmorBuilder_ && /*< other*/) noexcept -> ArmorBuilder_ & { return *this; } ///> =ops

    virtual ~ArmorBuilder_() = default; ///> destructor

    static const uint8_t MAGIC_1  = 1;  ///> magic number as static const member
    static const uint8_t MAGIC_3  = 3;  ///> magic number as static const member
    static const uint8_t MAGIC_4  = 4;  ///> magic number as static const member
    static const uint8_t MAGIC_5  = 5;  ///> magic number as static const member
    static const uint8_t MAGIC_7  = 6;  ///> magic number as static const member
    static const uint8_t MAGIC_12 = 12; ///> magic number as static const member
};

/// @brief a so-called CONCRETE BUILDER
class ArmorBuilder_Civilian : public ArmorBuilder_
{
  public:
    /// @brief concreate buildArmor function for ArmorBuilder_Civilian
    /// @return Armor adequate for Civilian, ... i.e. simple cloths
    [[nodiscard]] auto buildArmor() -> Armor override
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY, "Plain Shirt", MAGIC_1),
                      ArmorPart(ArmorPart::Type::LEGS, "Cloth trousers", MAGIC_1),
                      ArmorPart(ArmorPart::Type::FEET, "Simple Shoes", MAGIC_1)});
    }
};

/// @brief a so-called CONCRETE BUILDER
class ArmorBuilder_Warrior : public ArmorBuilder_
{
  public:
    /// @brief concreate buildArmor function for ArmorBuilder_Warrior
    /// @return Armor adequate for Warriors
    [[nodiscard]] auto buildArmor() -> Armor override
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY, "Leather Chest Protector", MAGIC_12),
                      ArmorPart(ArmorPart::Type::HEAD, "Leather Helmet", MAGIC_7),
                      ArmorPart(ArmorPart::Type::LEGS, "Bavarian Leather Trousers", MAGIC_5),
                      ArmorPart(ArmorPart::Type::HANDS, "Leather Gloves", MAGIC_4),
                      ArmorPart(ArmorPart::Type::FEET, "Leather Boots", MAGIC_3)});
    }
};

/// @brief a so-called CONCRETE BUILDER
class ArmorBuilder_Wizard : public ArmorBuilder_
{
  public:
    /// @brief concreate buildArmor function for ArmorBuilder_Wizard
    /// @return Armor adequate for Wizards
    [[nodiscard]] auto buildArmor() -> Armor override
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY, "Magic Rope", MAGIC_4),
                      ArmorPart(ArmorPart::Type::HEAD, "Pointed Hat", MAGIC_3),
                      ArmorPart(ArmorPart::Type::LEGS, "Long Underpants", MAGIC_1),
                      ArmorPart(ArmorPart::Type::FEET, "Slipers", MAGIC_1)});
    }
};

/// @brief The NPC basically serves as the director with conststructor serving
/// as creation function
class NPC
{
  public:
    /// @brief enum for warrior/wizard/civilian npc
    enum class Type : uint8_t
    {
        CIVILIAN,
        WARRIOR,
        WIZARD
    };

    NPC() = delete;

    /// @brief parameterized NPC constructor
    /// @param name of the NPC
    /// @param type of the NPC
    NPC(std::string name, const Type type) : name_(std::move(name)), type_(type)
    {
        switch ( type )
        {
            case Type::CIVILIAN:
                armor_ = ArmorBuilder_Civilian().buildArmor();
                break;
            case Type::WARRIOR:
                armor_ = ArmorBuilder_Warrior().buildArmor();
                break;
            case Type::WIZARD:
                armor_ = ArmorBuilder_Wizard().buildArmor();
                break;
            default:
                armor_ = Armor();
                break;
        }
    }

    /// @brief name getter
    /// @return name of NPC
    [[nodiscard]] auto getName() const -> std::string { return name_; }
    /// @brief type getter
    /// @return type of NPC
    [[nodiscard]] auto getType() const -> Type { return type_; }
    /// @brief Armor getter
    /// @return Armor of NPC
    [[nodiscard]] auto getArmor() const -> Armor { return armor_; }

  private:
    const std::string name_;  ///> name of the NPC
    const Type        type_;  ///> type of the NPC
    Armor             armor_; ///> armor of the NPC
};

/// @brief just a simple collection of functions for creation of different NPC types
class NPCBuilder
{
  public:

    /// @brief function building a civilian NPC with civilian Armor
    /// @param name of the NPC
    /// @return shared_ptr to freshly build NPC
    static auto civilian(const std::string &name) -> std::shared_ptr<NPC>
    {
        return std::make_shared<NPC>(name, NPC::Type::CIVILIAN);
    }

    /// @brief function building a warrior NPC with civilian Armor
    /// @param name of the NPC
    /// @return shared_ptr to freshly build NPC
    static auto warrior(const std::string &name) -> std::shared_ptr<NPC>
    {
        return std::make_shared<NPC>(name, NPC::Type::WARRIOR);
    }

    /// @brief function building a wizard NPC with civilian Armor
    /// @param name of the NPC
    /// @return shared_ptr to freshly build NPC
    static auto wizard(const std::string &name) -> std::shared_ptr<NPC> { return std::make_shared<NPC>(name, NPC::Type::WIZARD); }
};

#endif
