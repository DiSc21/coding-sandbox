//----------------------------------------------------------------------------------------------------
//- (SIMPLE) BUILDER Pattern  ------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------
// The builder pattern "separates the construction of a complex object from its representation".
// - This allows to create different representations with the same construction process.
// - Construction of complex objects is done step by step and the final step returns the object.
// - The construction process is generic to be be used for creation of different representations.
//
// NOTE: This is not an official GangOfFour pattern! It's a simplified version of the Builder pattern
//       for less complex products which skips the abstract Builder and the Director class.
//----------------------------------------------------------------------------------------------------
//
// COMPONENTS:
// -----------
// - PRODUCT:
//   Product class defines type of the object to be generated by the builder pattern.
//
// - CONCRETE BUILDER(S):
//   Daughter(s) of abstract Builder. Here, steps for creation of particular products are implemented.
//
//----------------------------------------------------------------------------------------------------
//
// ADVANTAGES:
// -----------
// - Parameters for constructor are reduced providing highly readable method calls.
// - Circumvents the need for optional parameters in the constructor.
// - Object is always instantiated in a complete state.
// - Immutable objects can be build without much complex logic in the object building process.
// - Usually yields a better design flexibility
// - Usually yields a better readable code.
//----------------------------------------------------------------------------------------------------
//
// DISADVANTAGES:
// --------------
// - Number of lines of code increase to double
// - Requires a separate ConcreteBuilder for each different type of Product.
//
//----------------------------------------------------------------------------------------------------

#ifndef __DS_ARMOR__
#define __DS_ARMOR__

#include <numeric>
#include <set>
#include <map>
#include <string>

/// @brief Just a an auxiliary class used in the PRODUCT class
class ArmorPart
{
  public:

    enum class Type : uint8_t
    {
        BODY,
        HEAD,
        SHOULDERS,
        ARMS,
        HANDS,
        LEGS,
        FEET,
        NONE 
    };

    ArmorPart() = delete;
    ArmorPart(const Type type, const std::string& name = "", uint8_t protection = 0)
        : type_(type), name_(name), protection_(protection)
    {}

    bool operator<(const ArmorPart& rhs) const { return (type_  < rhs.type_);}

    Type        getType()       const { return type_; }
    std::string getName()       const { return name_; }
    uint8_t     getProtection() const { return protection_; }

  private:
    const Type type_;

    std::string name_;
    uint8_t protection_;
};

/// @brief the so-called PRODUCT
class Armor
{
  public:
    Armor(){}
    Armor(std::set<ArmorPart> parts)
    {
        for(const auto& part: parts)
        {
            static_cast<void>(armor_parts_.insert({part.getType(), part}));
        }
    }

    uint8_t getTypeProtection(const ArmorPart::Type type) const
    {
        const auto& part_it = armor_parts_.find(type);
        return (part_it != armor_parts_.end()) ? part_it->second.getProtection() : 0;
    }

    uint16_t getProtection() const
    {
        return std::accumulate(std::begin(armor_parts_), std::end(armor_parts_), 0,
                               [](const std::uint16_t sum, const auto& part)
                               { return sum + part.second.getProtection(); });
    }

  private:
    std::map<ArmorPart::Type, ArmorPart> armor_parts_{};
};

/// @brief the so-called BUILDER
class ArmorBuilder
{
  public:
    static Armor civilian()
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY,  "Plain Shirt", 1),
                      ArmorPart(ArmorPart::Type::LEGS,  "Cloth trousers", 1),
                      ArmorPart(ArmorPart::Type::FEET,  "Simple Shoes", 1)});
    }
    static Armor warrior()
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY,  "Leather Chest Protector", 12),
                      ArmorPart(ArmorPart::Type::HEAD,  "Leather Helmet", 7),
                      ArmorPart(ArmorPart::Type::LEGS,  "Bavarian Leather Trousers", 5),
                      ArmorPart(ArmorPart::Type::HANDS, "Leather Gloves", 4),
                      ArmorPart(ArmorPart::Type::FEET,  "Leather Boots", 3)});
    }
    static Armor wizard()
    {
        return Armor({ArmorPart(ArmorPart::Type::BODY,  "Magic Rope", 4),
                      ArmorPart(ArmorPart::Type::HEAD,  "Pointed Hat", 3),
                      ArmorPart(ArmorPart::Type::LEGS,  "Long Underpants", 1),
                      ArmorPart(ArmorPart::Type::FEET,  "Slipers", 1)});
    }
};

#endif

