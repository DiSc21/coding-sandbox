//*****************************************************************************************|
//     ______ _              ____            _      ,                      _               |
//    (_) |  | |            (|   \ o        | |    /|   /         o       | |              |
//        |  | |     _       |    |    ,_   | |     |__/   _  _       __, | |   _|_        |
//      _ |  |/ \   |/      _|    ||  /  |  |/_)    | \   / |/ |  |  /  | |/ \   |         |
//     (_/   |   |_/|__/   (/\___/ |_/   |_/| \_/   |  \_/  |  |_/|_/\_/|/|   |_/|_/       |
//    *****************************************************************/|***********       |
//                                                                     \|                  |
//_________________________________________________________________________________________|
//                                                                                         |
// Copyright (c) 2023  DiSc21-Fantasies@TDK. All rights reserved.                          |
// None of the code is licensed under any License.                                         |
//_________________________________________________________________________________________|
//
//------------------------------------------------------------------------------------------
//- (SIMPLE) BUILDER Pattern  --------------------------------------------------------------
//------------------------------------------------------------------------------------------
// Builder pattern "separates the construction of a complex object from its representation".
// - Allows to create different representations with the same construction process.
// - Constructing complex objects step by step and the final step returns the object.
// - Construction process is generic to be used for creation of different representations.
//
// NOTE: This is not an official GangOfFour pattern! It's a simplified version of the
//       Builder pattern for less complex products which skips the abstract Builder and
//      the Director class.
//------------------------------------------------------------------------------------------
//
// COMPONENTS:
// -----------
// - PRODUCT:
//   Product class defines type of the object to be generated by the builder pattern.
//
// - CONCRETE BUILDER(S):
//   Daughter(s) of abstract Builder. Here, creation of particular products is implemented.
//
//------------------------------------------------------------------------------------------
//
// ADVANTAGES:
// -----------
// - Parameters for constructor are reduced providing highly readable method calls.
// - Circumvents the need for optional parameters in the constructor.
// - Object is always instantiated in a complete state.
// - Immutable objects can be build without much complex logic in object building process.
// - Usually yields a better design flexibility
// - Usually yields a better readable code.
//------------------------------------------------------------------------------------------
//
// DISADVANTAGES:
// --------------
// - Number of lines of code increase to double
// - Requires a separate ConcreteBuilder for each different type of Product.
//
//------------------------------------------------------------------------------------------

#ifndef DS_ARMOR_HPP
#define DS_ARMOR_HPP

#include <map>
#include <numeric>
#include <set>
#include <string>
#include <utility>

/// @brief Just a an auxiliary class used in the PRODUCT class
class SimpleArmorPart
{
  public:
    /// @brief simple enum descriping different armor/body parts
    enum class Type : uint8_t
    {
        BODY,
        HEAD,
        SHOULDERS,
        ARMS,
        HANDS,
        LEGS,
        FEET,
        NONE
    };

    SimpleArmorPart() = delete;
    // clang-format off
    /// @brief construnctor for armor parts
    /// @param type the type of the armor part
    /// @param name the name of the armor part
    /// @param protection the value of protection
    explicit SimpleArmorPart(const Type type, std::string name = "", uint8_t protection = 0)
        : type_(type), name_(std::move(name)), protection_(protection)
    {
    }

    /// @brief comparison operator needed to collect ArmorPart in set
    /// @param rhs the ArmorPart standing on the rhs of the operator
    /// @return boolean, true if type smaller than rhs type
    auto operator<(const SimpleArmorPart &rhs) const -> bool { return (type_ < rhs.type_); }

    /// @brief type getter
    /// @return type of ArmorPart
    [[nodiscard]] auto getType() const -> Type { return type_; }
    /// @brief name getter
    /// @return name of ArmorPart
    [[nodiscard]] auto getName() const -> std::string { return name_; }
    /// @brief protection getter
    /// @return protection of ArmorPart
    [[nodiscard]] auto getProtection() const -> uint8_t { return protection_; }

  private:
    /// @brief const armor type
    const Type type_;

    /// @brief name of armor part
    std::string name_;
    /// @brief protection vlaue of armor part
    uint8_t protection_;
};

/// @brief the so-called PRODUCT
class SimpleArmor
{
  public:
    SimpleArmor() = default; ///> the defaulted default constructor

    /// @brief single argument constructor creating armor from set of Armor parts
    /// @param parts set of armor parts
    explicit SimpleArmor(const std::set<SimpleArmorPart> &parts)
    {
        for ( const auto &part : parts )
        {
            static_cast<void>(armor_parts_.insert({part.getType(), part}));
        }
    }

    /// @brief getter protection value for armor part-type
    /// @param type the armor part-type protection value is requested
    /// @return protection value for requested part
    [[nodiscard]] auto getTypeProtection(const SimpleArmorPart::Type type) const -> uint8_t
    {
        const auto &part_it = armor_parts_.find(type);
        return (part_it != armor_parts_.end()) ? part_it->second.getProtection() : 0;
    }

    /// @brief getter protection value for full armor
    /// @return protection value for full armor
    [[nodiscard]] auto getProtection() const -> uint16_t
    {
        // clang-format off
        return std::accumulate(std::begin(armor_parts_), std::end(armor_parts_), 0,
                               [](const std::uint16_t sum, const auto &part) { return sum + part.second.getProtection(); });
        // clang-format on
    }

  private:
    /// @brief map of armorPartType to equiped armor part
    std::map<SimpleArmorPart::Type, SimpleArmorPart> armor_parts_{};
};

/// @brief the so-called BUILDER
class SimpleArmorBuilder
{
  public:
    /// @brief concrete build function for civilian armor
    /// @return SimpleArmor
    static auto civilian() -> SimpleArmor
    {
        return SimpleArmor({SimpleArmorPart(SimpleArmorPart::Type::BODY, "Plain Shirt", MAGIC_1),
                            SimpleArmorPart(SimpleArmorPart::Type::LEGS, "Cloth trousers", MAGIC_1),
                            SimpleArmorPart(SimpleArmorPart::Type::FEET, "Simple Shoes", MAGIC_1)});
    }
    /// @brief concrete build function for warrior armor
    /// @return SimpleArmor
    static auto warrior() -> SimpleArmor
    {
        return SimpleArmor({SimpleArmorPart(SimpleArmorPart::Type::BODY, "Leather Chest Protector", MAGIC_12),
                            SimpleArmorPart(SimpleArmorPart::Type::HEAD, "Leather Helmet", MAGIC_7),
                            SimpleArmorPart(SimpleArmorPart::Type::LEGS, "Bavarian Leather Trousers", MAGIC_5),
                            SimpleArmorPart(SimpleArmorPart::Type::HANDS, "Leather Gloves", MAGIC_4),
                            SimpleArmorPart(SimpleArmorPart::Type::FEET, "Leather Boots", MAGIC_3)});
    }
    /// @brief concrete build function for wizard armor
    /// @return SimpleArmor
    static auto wizard() -> SimpleArmor
    {
        return SimpleArmor({SimpleArmorPart(SimpleArmorPart::Type::BODY, "Magic Rope", MAGIC_4),
                            SimpleArmorPart(SimpleArmorPart::Type::HEAD, "Pointed Hat", MAGIC_3),
                            SimpleArmorPart(SimpleArmorPart::Type::LEGS, "Long Underpants", MAGIC_1),
                            SimpleArmorPart(SimpleArmorPart::Type::FEET, "Slipers", MAGIC_1)});
    }

    /// @brief magic number as static const member
    static const uint8_t MAGIC_1  = 1; ///> magic number as static const member
    static const uint8_t MAGIC_3  = 3; ///> magic number as static const member
    static const uint8_t MAGIC_4  = 4; ///> magic number as static const member
    static const uint8_t MAGIC_5  = 5; ///> magic number as static const member
    static const uint8_t MAGIC_7  = 6; ///> magic number as static const member
    static const uint8_t MAGIC_12 = 12; ///> magic number as static const member
};

#endif
